// Code generated by MockGen. DO NOT EDIT.
// Source: interfaces.go
//
// Generated by this command:
//
//	mockgen -typed -package=usecases_mock -source=interfaces.go -destination=../../../mocks/generated_func_mocks.go
//

// Package usecases_mock is a generated GoMock package.
package usecases_mock

import (
	context "context"
	reflect "reflect"

	entity "github.com/project/library/internal/entity"
	gomock "go.uber.org/mock/gomock"
)

// MockAuthorUseCase is a mock of AuthorUseCase interface.
type MockAuthorUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorUseCaseMockRecorder
	isgomock struct{}
}

// MockAuthorUseCaseMockRecorder is the mock recorder for MockAuthorUseCase.
type MockAuthorUseCaseMockRecorder struct {
	mock *MockAuthorUseCase
}

// NewMockAuthorUseCase creates a new mock instance.
func NewMockAuthorUseCase(ctrl *gomock.Controller) *MockAuthorUseCase {
	mock := &MockAuthorUseCase{ctrl: ctrl}
	mock.recorder = &MockAuthorUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthorUseCase) EXPECT() *MockAuthorUseCaseMockRecorder {
	return m.recorder
}

// ChangeAuthorInfo mocks base method.
func (m *MockAuthorUseCase) ChangeAuthorInfo(ctx context.Context, authorID, authorName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeAuthorInfo", ctx, authorID, authorName)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChangeAuthorInfo indicates an expected call of ChangeAuthorInfo.
func (mr *MockAuthorUseCaseMockRecorder) ChangeAuthorInfo(ctx, authorID, authorName any) *MockAuthorUseCaseChangeAuthorInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeAuthorInfo", reflect.TypeOf((*MockAuthorUseCase)(nil).ChangeAuthorInfo), ctx, authorID, authorName)
	return &MockAuthorUseCaseChangeAuthorInfoCall{Call: call}
}

// MockAuthorUseCaseChangeAuthorInfoCall wrap *gomock.Call
type MockAuthorUseCaseChangeAuthorInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockAuthorUseCaseChangeAuthorInfoCall) Return(arg0 error) *MockAuthorUseCaseChangeAuthorInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockAuthorUseCaseChangeAuthorInfoCall) Do(f func(context.Context, string, string) error) *MockAuthorUseCaseChangeAuthorInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockAuthorUseCaseChangeAuthorInfoCall) DoAndReturn(f func(context.Context, string, string) error) *MockAuthorUseCaseChangeAuthorInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAuthor mocks base method.
func (m *MockAuthorUseCase) GetAuthor(ctx context.Context, authorID string) (entity.Author, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAuthor", ctx, authorID)
	ret0, _ := ret[0].(entity.Author)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAuthor indicates an expected call of GetAuthor.
func (mr *MockAuthorUseCaseMockRecorder) GetAuthor(ctx, authorID any) *MockAuthorUseCaseGetAuthorCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAuthor", reflect.TypeOf((*MockAuthorUseCase)(nil).GetAuthor), ctx, authorID)
	return &MockAuthorUseCaseGetAuthorCall{Call: call}
}

// MockAuthorUseCaseGetAuthorCall wrap *gomock.Call
type MockAuthorUseCaseGetAuthorCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockAuthorUseCaseGetAuthorCall) Return(arg0 entity.Author, arg1 error) *MockAuthorUseCaseGetAuthorCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockAuthorUseCaseGetAuthorCall) Do(f func(context.Context, string) (entity.Author, error)) *MockAuthorUseCaseGetAuthorCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockAuthorUseCaseGetAuthorCall) DoAndReturn(f func(context.Context, string) (entity.Author, error)) *MockAuthorUseCaseGetAuthorCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAuthorBooks mocks base method.
func (m *MockAuthorUseCase) GetAuthorBooks(ctx context.Context, authorID string) ([]entity.Book, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAuthorBooks", ctx, authorID)
	ret0, _ := ret[0].([]entity.Book)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAuthorBooks indicates an expected call of GetAuthorBooks.
func (mr *MockAuthorUseCaseMockRecorder) GetAuthorBooks(ctx, authorID any) *MockAuthorUseCaseGetAuthorBooksCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAuthorBooks", reflect.TypeOf((*MockAuthorUseCase)(nil).GetAuthorBooks), ctx, authorID)
	return &MockAuthorUseCaseGetAuthorBooksCall{Call: call}
}

// MockAuthorUseCaseGetAuthorBooksCall wrap *gomock.Call
type MockAuthorUseCaseGetAuthorBooksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockAuthorUseCaseGetAuthorBooksCall) Return(arg0 []entity.Book, arg1 error) *MockAuthorUseCaseGetAuthorBooksCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockAuthorUseCaseGetAuthorBooksCall) Do(f func(context.Context, string) ([]entity.Book, error)) *MockAuthorUseCaseGetAuthorBooksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockAuthorUseCaseGetAuthorBooksCall) DoAndReturn(f func(context.Context, string) ([]entity.Book, error)) *MockAuthorUseCaseGetAuthorBooksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RegisterAuthor mocks base method.
func (m *MockAuthorUseCase) RegisterAuthor(ctx context.Context, authorName string) (entity.Author, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegisterAuthor", ctx, authorName)
	ret0, _ := ret[0].(entity.Author)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RegisterAuthor indicates an expected call of RegisterAuthor.
func (mr *MockAuthorUseCaseMockRecorder) RegisterAuthor(ctx, authorName any) *MockAuthorUseCaseRegisterAuthorCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterAuthor", reflect.TypeOf((*MockAuthorUseCase)(nil).RegisterAuthor), ctx, authorName)
	return &MockAuthorUseCaseRegisterAuthorCall{Call: call}
}

// MockAuthorUseCaseRegisterAuthorCall wrap *gomock.Call
type MockAuthorUseCaseRegisterAuthorCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockAuthorUseCaseRegisterAuthorCall) Return(arg0 entity.Author, arg1 error) *MockAuthorUseCaseRegisterAuthorCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockAuthorUseCaseRegisterAuthorCall) Do(f func(context.Context, string) (entity.Author, error)) *MockAuthorUseCaseRegisterAuthorCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockAuthorUseCaseRegisterAuthorCall) DoAndReturn(f func(context.Context, string) (entity.Author, error)) *MockAuthorUseCaseRegisterAuthorCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockBooksUseCase is a mock of BooksUseCase interface.
type MockBooksUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockBooksUseCaseMockRecorder
	isgomock struct{}
}

// MockBooksUseCaseMockRecorder is the mock recorder for MockBooksUseCase.
type MockBooksUseCaseMockRecorder struct {
	mock *MockBooksUseCase
}

// NewMockBooksUseCase creates a new mock instance.
func NewMockBooksUseCase(ctrl *gomock.Controller) *MockBooksUseCase {
	mock := &MockBooksUseCase{ctrl: ctrl}
	mock.recorder = &MockBooksUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBooksUseCase) EXPECT() *MockBooksUseCaseMockRecorder {
	return m.recorder
}

// GetBook mocks base method.
func (m *MockBooksUseCase) GetBook(ctx context.Context, bookID string) (entity.Book, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBook", ctx, bookID)
	ret0, _ := ret[0].(entity.Book)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBook indicates an expected call of GetBook.
func (mr *MockBooksUseCaseMockRecorder) GetBook(ctx, bookID any) *MockBooksUseCaseGetBookCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBook", reflect.TypeOf((*MockBooksUseCase)(nil).GetBook), ctx, bookID)
	return &MockBooksUseCaseGetBookCall{Call: call}
}

// MockBooksUseCaseGetBookCall wrap *gomock.Call
type MockBooksUseCaseGetBookCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBooksUseCaseGetBookCall) Return(arg0 entity.Book, arg1 error) *MockBooksUseCaseGetBookCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBooksUseCaseGetBookCall) Do(f func(context.Context, string) (entity.Book, error)) *MockBooksUseCaseGetBookCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBooksUseCaseGetBookCall) DoAndReturn(f func(context.Context, string) (entity.Book, error)) *MockBooksUseCaseGetBookCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RegisterBook mocks base method.
func (m *MockBooksUseCase) RegisterBook(ctx context.Context, name string, authorIDs []string) (entity.Book, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegisterBook", ctx, name, authorIDs)
	ret0, _ := ret[0].(entity.Book)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RegisterBook indicates an expected call of RegisterBook.
func (mr *MockBooksUseCaseMockRecorder) RegisterBook(ctx, name, authorIDs any) *MockBooksUseCaseRegisterBookCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterBook", reflect.TypeOf((*MockBooksUseCase)(nil).RegisterBook), ctx, name, authorIDs)
	return &MockBooksUseCaseRegisterBookCall{Call: call}
}

// MockBooksUseCaseRegisterBookCall wrap *gomock.Call
type MockBooksUseCaseRegisterBookCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBooksUseCaseRegisterBookCall) Return(arg0 entity.Book, arg1 error) *MockBooksUseCaseRegisterBookCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBooksUseCaseRegisterBookCall) Do(f func(context.Context, string, []string) (entity.Book, error)) *MockBooksUseCaseRegisterBookCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBooksUseCaseRegisterBookCall) DoAndReturn(f func(context.Context, string, []string) (entity.Book, error)) *MockBooksUseCaseRegisterBookCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateBook mocks base method.
func (m *MockBooksUseCase) UpdateBook(ctx context.Context, bookID, name string, authorIDs []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateBook", ctx, bookID, name, authorIDs)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateBook indicates an expected call of UpdateBook.
func (mr *MockBooksUseCaseMockRecorder) UpdateBook(ctx, bookID, name, authorIDs any) *MockBooksUseCaseUpdateBookCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateBook", reflect.TypeOf((*MockBooksUseCase)(nil).UpdateBook), ctx, bookID, name, authorIDs)
	return &MockBooksUseCaseUpdateBookCall{Call: call}
}

// MockBooksUseCaseUpdateBookCall wrap *gomock.Call
type MockBooksUseCaseUpdateBookCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBooksUseCaseUpdateBookCall) Return(arg0 error) *MockBooksUseCaseUpdateBookCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBooksUseCaseUpdateBookCall) Do(f func(context.Context, string, string, []string) error) *MockBooksUseCaseUpdateBookCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBooksUseCaseUpdateBookCall) DoAndReturn(f func(context.Context, string, string, []string) error) *MockBooksUseCaseUpdateBookCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
